// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: subscriptions.sql

package queries

import (
	"context"
	"database/sql"
)

const canMakeRequest = `-- name: CanMakeRequest :one
SELECT request_count < ? AS can_request FROM subscriptions WHERE id = ?
`

type CanMakeRequestParams struct {
	RequestCount sql.NullInt64 `db:"request_count" json:"request_count"`
	ID           int64         `db:"id" json:"id"`
}

func (q *Queries) CanMakeRequest(ctx context.Context, arg CanMakeRequestParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, canMakeRequest, arg.RequestCount, arg.ID)
	var can_request bool
	err := row.Scan(&can_request)
	return can_request, err
}

const createSubscription = `-- name: CreateSubscription :one
INSERT INTO subscriptions (url, name, enabled)
VALUES (?, ?, ?)
RETURNING id, url, name, enabled, last_updated_at, last_error, request_count, request_count_reset_at, created_at
`

type CreateSubscriptionParams struct {
	Url     string         `db:"url" json:"url"`
	Name    sql.NullString `db:"name" json:"name"`
	Enabled sql.NullInt64  `db:"enabled" json:"enabled"`
}

func (q *Queries) CreateSubscription(ctx context.Context, arg CreateSubscriptionParams) (Subscription, error) {
	row := q.db.QueryRowContext(ctx, createSubscription, arg.Url, arg.Name, arg.Enabled)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.Name,
		&i.Enabled,
		&i.LastUpdatedAt,
		&i.LastError,
		&i.RequestCount,
		&i.RequestCountResetAt,
		&i.CreatedAt,
	)
	return i, err
}

const deleteSubscription = `-- name: DeleteSubscription :exec
DELETE FROM subscriptions WHERE id = ?
`

func (q *Queries) DeleteSubscription(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteSubscription, id)
	return err
}

const getAllSubscriptions = `-- name: GetAllSubscriptions :many
SELECT id, url, name, enabled, last_updated_at, last_error, request_count, request_count_reset_at, created_at FROM subscriptions ORDER BY created_at DESC
`

func (q *Queries) GetAllSubscriptions(ctx context.Context) ([]Subscription, error) {
	rows, err := q.db.QueryContext(ctx, getAllSubscriptions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Name,
			&i.Enabled,
			&i.LastUpdatedAt,
			&i.LastError,
			&i.RequestCount,
			&i.RequestCountResetAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEnabledSubscriptions = `-- name: GetEnabledSubscriptions :many
SELECT id, url, name, enabled, last_updated_at, last_error, request_count, request_count_reset_at, created_at FROM subscriptions WHERE enabled = 1 ORDER BY created_at DESC
`

func (q *Queries) GetEnabledSubscriptions(ctx context.Context) ([]Subscription, error) {
	rows, err := q.db.QueryContext(ctx, getEnabledSubscriptions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Name,
			&i.Enabled,
			&i.LastUpdatedAt,
			&i.LastError,
			&i.RequestCount,
			&i.RequestCountResetAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubscriptionByID = `-- name: GetSubscriptionByID :one
SELECT id, url, name, enabled, last_updated_at, last_error, request_count, request_count_reset_at, created_at FROM subscriptions WHERE id = ?
`

func (q *Queries) GetSubscriptionByID(ctx context.Context, id int64) (Subscription, error) {
	row := q.db.QueryRowContext(ctx, getSubscriptionByID, id)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.Name,
		&i.Enabled,
		&i.LastUpdatedAt,
		&i.LastError,
		&i.RequestCount,
		&i.RequestCountResetAt,
		&i.CreatedAt,
	)
	return i, err
}

const getSubscriptionByURL = `-- name: GetSubscriptionByURL :one
SELECT id, url, name, enabled, last_updated_at, last_error, request_count, request_count_reset_at, created_at FROM subscriptions WHERE url = ?
`

func (q *Queries) GetSubscriptionByURL(ctx context.Context, url string) (Subscription, error) {
	row := q.db.QueryRowContext(ctx, getSubscriptionByURL, url)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.Name,
		&i.Enabled,
		&i.LastUpdatedAt,
		&i.LastError,
		&i.RequestCount,
		&i.RequestCountResetAt,
		&i.CreatedAt,
	)
	return i, err
}

const getSubscriptionsNeedingReset = `-- name: GetSubscriptionsNeedingReset :many
SELECT id, url, name, enabled, last_updated_at, last_error, request_count, request_count_reset_at, created_at FROM subscriptions
WHERE request_count_reset_at < datetime('now', '-1 hour')
`

func (q *Queries) GetSubscriptionsNeedingReset(ctx context.Context) ([]Subscription, error) {
	rows, err := q.db.QueryContext(ctx, getSubscriptionsNeedingReset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subscription{}
	for rows.Next() {
		var i Subscription
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Name,
			&i.Enabled,
			&i.LastUpdatedAt,
			&i.LastError,
			&i.RequestCount,
			&i.RequestCountResetAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementRequestCount = `-- name: IncrementRequestCount :exec
UPDATE subscriptions
SET request_count = request_count + 1
WHERE id = ?
`

func (q *Queries) IncrementRequestCount(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, incrementRequestCount, id)
	return err
}

const resetRequestCount = `-- name: ResetRequestCount :exec
UPDATE subscriptions
SET request_count = 0, request_count_reset_at = CURRENT_TIMESTAMP
WHERE id = ?
`

func (q *Queries) ResetRequestCount(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, resetRequestCount, id)
	return err
}

const subscriptionExists = `-- name: SubscriptionExists :one
SELECT EXISTS(SELECT 1 FROM subscriptions WHERE url = ?) AS sub_exists
`

func (q *Queries) SubscriptionExists(ctx context.Context, url string) (int64, error) {
	row := q.db.QueryRowContext(ctx, subscriptionExists, url)
	var sub_exists int64
	err := row.Scan(&sub_exists)
	return sub_exists, err
}

const updateSubscription = `-- name: UpdateSubscription :exec
UPDATE subscriptions
SET name = ?, enabled = ?
WHERE id = ?
`

type UpdateSubscriptionParams struct {
	Name    sql.NullString `db:"name" json:"name"`
	Enabled sql.NullInt64  `db:"enabled" json:"enabled"`
	ID      int64          `db:"id" json:"id"`
}

func (q *Queries) UpdateSubscription(ctx context.Context, arg UpdateSubscriptionParams) error {
	_, err := q.db.ExecContext(ctx, updateSubscription, arg.Name, arg.Enabled, arg.ID)
	return err
}

const updateSubscriptionError = `-- name: UpdateSubscriptionError :exec
UPDATE subscriptions
SET last_error = ?
WHERE id = ?
`

type UpdateSubscriptionErrorParams struct {
	LastError sql.NullString `db:"last_error" json:"last_error"`
	ID        int64          `db:"id" json:"id"`
}

func (q *Queries) UpdateSubscriptionError(ctx context.Context, arg UpdateSubscriptionErrorParams) error {
	_, err := q.db.ExecContext(ctx, updateSubscriptionError, arg.LastError, arg.ID)
	return err
}

const updateSubscriptionLastUpdated = `-- name: UpdateSubscriptionLastUpdated :exec
UPDATE subscriptions
SET last_updated_at = CURRENT_TIMESTAMP, last_error = NULL
WHERE id = ?
`

func (q *Queries) UpdateSubscriptionLastUpdated(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, updateSubscriptionLastUpdated, id)
	return err
}
